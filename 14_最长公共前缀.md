## 题目
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

**示例1**
```
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例2**
```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明**
所有输入只包含小写字母 a-z 。

## 代码
```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int len = strs.size();
        if(len == 0){
            return "";
        }
        if(len == 1){
            return strs[0];
        }
        for(int i = 0; i < strs[0].size();i++){
            for(int j = 1;j < len;j++){
                if(strs[j].size() < i || strs[j][i] != strs[0][i]){
                    return strs[0].substr(0,i);
                }
            }
        }
        return strs[0];
    }
};
```
## 思路

这道题很简单，维护一个当前公共前缀长度index，然后每次遍历一下列表，若出现某个元素的长度小于当前index值或者某元素第index位与其前一个元素第index位不相同则代表已经找到了最大前缀，否则就一直加直到index位strs[0].size()时为止。

* 时间复杂度：O(S)，S 是所有字符串中字符数量的总和。最坏情况下，输入数据为 n 个长度为 m 的相同字符串，算法会进行 S = m*n 次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 n*minLen 次比较，其中 minLen 是数组中最短字符串的长度。
* 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。

此[博客](https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/)还有一些有趣的讨论，如果是一个长期的建议搞成trie树来存。