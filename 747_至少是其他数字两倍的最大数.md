## 题目
在一个给定的数组nums中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。

**示例1**
```
输入: nums = [3, 6, 1, 0]
输出: 1
解释: 6是最大的整数, 对于数组中的其他整数,
6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.
```

**示例2**
```
输入: nums = [1, 2, 3, 4]
输出: -1
解释: 4没有超过3的两倍大, 所以我们返回 -1.
```

**说明**

* nums 的长度范围在[1, 50]。
* 每个 nums[i] 的整数范围在 [0, 100]。

## 代码
```C++
class Solution {
public:    
    int dominantIndex(vector<int>& nums) {
        int len = nums.size();
        int max = -1;
        int max1 = -1;
        int index = 0;
        for(int i = 0;i < len ;i++){
            if(max < nums[i]){
                max1 = max;
                max = nums[i];
                index = i;
            }
            else if(max1 < nums[i]){
                max1 = nums[i];
            }
        }
        return max >= 2 * max1 ? index : -1; 
    }
};
```
## 思路

这道题写起来比较暴力肯定不会出错的算法就是先排个序，再取最大的两个数判断是否满足题意即可，这样复杂度是`O(nlogn)`的，但很容易可以看出来这道题`O(n)`就可以解决。这道题实际是求一个数组中最大的两个值，所以遍历一遍找到最大的两个值即可，就是需要注意如何维护第二大的值，这里很容易出错。