## 代码
```C++
class Solution {
public:    
    int dominantIndex(vector<int>& nums) {
        int len = nums.size();
        int max = -1;
        int max1 = -1;
        int index = 0;
        for(int i = 0;i < len ;i++){
            if(max < nums[i]){
                max1 = max;
                max = nums[i];
                index = i;
            }
            else if(max1 < nums[i]){
                max1 = nums[i];
            }
        }
        return max >= 2 * max1 ? index : -1; 
    }
};
```
## 思路

这道题写起来比较暴力肯定不会出错的算法就是先排个序，再取最大的两个数判断是否满足题意即可，这样复杂度是`O(nlogn)`的，但很容易可以看出来这道题`O(n)`就可以解决。这道题实际是求一个数组中最大的两个值，所以遍历一遍找到最大的两个值即可，就是需要注意如何维护第二大的值，这里很容易出错。